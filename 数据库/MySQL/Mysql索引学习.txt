
1.对于多表查询我们的优化原则是： 
　　尽量将索引建立在：left join on/right join on ...　＋条件，的条件语句中所涉及的字段上。 

2.索引应该建立在查询条件中进行比较的字段上，而不是建立在我们要找出来并且显示的字段上.

3.IN、OR子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子句中应该包含索引。

4.索引带来查询上的速度的大大提升,但索引也占用了额外的硬盘空间(当然现在一般硬盘空间不成问题),而且往表中插入新记录时索引也要随着更新这也需要一定时间. 

5.组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就要做相应的更新工作。 

6.在海量查询时尽量少用格式转换。 

7.使用ORDER BY和GROUP BY短语，任何一种索引都有助于SELECT的性能提高。 

8.MySQL有两种存储引擎：MyISAM和InnoDB。

9.对那些还没有在数据库学习很深入的人来说，索引可以看作是就是hash排序。

10.关于连接条件的优化在顺序上有个原则：数剧量少的条件尽量写在前面。

11.explain 可以分析 select 语句的执行，即 MySQL 的“执行计划。
从EXPLAIN的输出包括下面列：

　　・table 输出的行所引用的表。

　　・ type 联结类型。各种类型的信息在下面给出。不同的联结类型列在下面，以最好到最差类型的次序： 

	system const eq_ref ref range index ALL

    ・ possible_keys 提示使用哪个索引会在该表中找到行，不太重要

　　・ key 显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。

　　・ key_len 显示MySQL决定使用的键长度。如果键是NULL，长度是NULL。注意这告诉我们MySQL将实际使用一个多部键值的几个部分。

　　・ ref 显示哪个列或常数与key一起用于从表中选择行。

　　・ rows 显示MySQL必须检验以执行查询的行数。

　　・Extra 如果Extra列包括文字Only index，这意味着信息只用索引树中的信息检索出的。通常，这比扫描整个表要快。如果Extra列包括文字where used，它意味着一个WHERE子句将被用来限制哪些行与下一个表匹配或发向客户。




索引建立的原则：

1. 在经常用作过滤器的字段上建立索引；
 
2. 在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引；
 
3. 在唯一性比较强的字段上建立索引，在不同值较少的字段上不必建立索引，如性别字段；
 
4. 对于经常存取的列避免建立索引；
 
5. 用于联接的列（主健/外健）上建立索引；
 
6. 在经常存取的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频度来确定；
 
7. 缺省情况下建立的是非簇集索引，但在以下情况下最好考虑簇集索引，如：含有有限数目（不是很少）唯一的列；进行大范围的查询；充分的利用索引可以减少表扫描I/0的次数，有效的避免对整表的搜索。

当然合理的索引要建立在对各种查询的分析和预测中，也取决于DBA的所设计的数据库结构（查询优化、索引优化、库表结构优化）。









复合索引：

联合索引又叫复合索引。对于复合索引：Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index （a,b,c）。 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。

    两个或更多个列上的索引被称作复合索引。

    利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。

    所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。

    如：建立 姓名、年龄、性别的复合索引。

    create table test（

    a int,

    b int,

    c int,

    KEY a（a,b,c）

    ）；

    优： select * from test where a=10 and b>50

    差： select * from test where a50

    优： select * from test order by a

    差： select * from test order by b

    差： select * from test order by c

    优： select * from test where a=10 order by a

    优： select * from test where a=10 order by b

    差： select * from test where a=10 order by c

    优： select * from test where a>10 order by a

    差： select * from test where a>10 order by b

    差： select * from test where a>10 order by c

    优： select * from test where a=10 and b=10 order by a

    优： select * from test where a=10 and b=10 order by b

    优： select * from test where a=10 and b=10 order by c

    优： select * from test where a=10 and b=10 order by a

    优： select * from test where a=10 and b>10 order by b

    差： select * from test where a=10 and b>10 order by c



 

    索引原则

    1.索引越少越好

    原因：主要在修改数据时，第个索引都要进行更新，降低写速度。

    2.最窄的字段放在键的左边

    3.避免file sort排序，临时表和表扫描。







哈希Hash索引和B-Tree索引的区别：


Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。

可 能很多人又有疑问了，既然 Hash 索引的效率要比 B-Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B-Tree 索引呢？任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。

（1）Hash 索引是基于等值计算的，仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。

由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。

（2）Hash 索引无法被用于排序操作。

由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；

（3）Hash 索引不能利用部分索引键查询，字段要么全用要么全不用，B-Tree支持的联合索引的最优前缀。

对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

（4）Hash 索引在任何时候都不能避免表扫描。

前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。

（5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。

对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。





索引的类型：

索引是在数据库表或者视图上创建的对象，目的是为了加快对表或视图的查询的速度。

按照存储方式分为：聚集与非聚集索引
按照维护与管理索引角度分为：唯一索引、复合索引和系统自动创建的索引。

索引的结构是由：根节点--->非叶节点--->非叶节点--->叶节点

1、聚集索引:表中存储的数据按照索引的顺序存储,检索效率比普通索引高,但对数据新增/修改/删除的影响比较大。逻辑顺序决定了表中相应行的物理顺序。
特点：
　 (1) 一个表可以最多可以创建249个索引
　 (2) 先建聚集索引才能创建非聚集索引
(3) 非聚集索引数据与索引不同序
(4) 数据与索引在不同位置
(5) 索引在叶节点上存储,在叶节点上有一个＂指针＂直接指向要查询的数据区域
(6) 数据不会根据索引键的顺序重新排列数据

(7)如果在该字段上进行范围查询，或者该表很少做增删改

　创建聚集索引的语法：
create NONCLUSTERED INDEX idximpID ON EMP(empID)

２、非聚集索引:不影响表中的数据存储顺序,检索效率比聚集索引低,对数据新增/修改/删除的影响很少
。是通过二叉树的数据结构来描述的，逻辑顺序，特点：
(1) 无索引，数据无序
(2) 有索引，数据与索引同序 
(3) 数据会根据索引键的顺序重新排列数据
(4) 一个表只能有一个索引
(5) 叶节点的指针指向的数据也在同一位置存储
语法：
create CLUSTERED INDEX idxempID on emp(empID)

３、惟一索引：惟一索引可以确保索引列不包含重复的值.
可以用多个列，但是索引可以确保索引列中每个值组合都是唯一的
姓 名
李 二
张 三
王 五
语法： create unique index idxempid on emp(姓，名)

4、复合索引：如果在两上以上的列上创建一个索引，则称为复合索引。
那么，不可能有两行的姓和名是重复的
语法：
create index indxfullname on addressbook(firstname,lastname)

注意：如果把复合的聚集索引字段分开查询。
带着这个问题，我们来看一下以下的查询速度（结果集都是25万条数据）：（日期列fariqi首先排在复合聚集索引的起始列，用户名neibuyonghu排在后列）：
（1）select gid,fariqi,neibuyonghu,title from Tgongwen where fariqi>''2004-5-5''
查询速度：2513毫秒
（2）select gid,fariqi,neibuyonghu,title from Tgongwen where fariqi>''2004-5-5'' and neibuyonghu=''办公室''
查询速度：2516毫秒
（3）select gid,fariqi,neibuyonghu,title from Tgongwen where neibuyonghu=''办公室''
查询速度：60280毫秒
　从以上试验中，我们可以看到如果仅用聚集索引的起始列作为查询条件和同时用到复合聚集索引的全部列的查询速度是几乎一样的，甚至比用上全部的复合索引列还要略快（在查询结果集数目一样的情况下）；而如果仅用复合聚集索引的非起始列作为查询条件的话，这个索引是不起任何作用的。当然，语句1、2的查询速度一样是因为查询的条目数一样，如果复合索引的所有列都用上，而且查询结果少的话，这样就会形成“索引覆盖”，因而性能可以达到最优。同时，请记住：无论您是否经常使用聚合索引的其他列，但其前导列一定要是使用最频繁的列。

5、系统自建的索引:在使用T_sql语句创建表的时候使用PRIMARY KEY或UNIQUE约束时，会在表上自动创建一个惟一索引
自动创建的索引是无法删除的
语法：
create table ABc
( empID int primary key,
firstname varchar(50)UNIQUE,
lastname varchar(50)UNIQUE,
)
这样的结果就出来了三个索引，但只有一个聚集索引哦

　
二、何时使用聚集索引或非聚集索引

下面的表总结了何时使用聚集索引或非聚集索引（很重要）：

动作描述	使用聚集索引	使用非聚集索引

列经常被分组排序	应	应
返回某范围内的数据	应	不应
一个或极少不同值	不应	不应
小数目的不同值		应	不应
大数目的不同值		不应	应
频繁更新的列		不应	应
外键列			应	应
主键列			应	应
频繁修改索引列		不应	应



